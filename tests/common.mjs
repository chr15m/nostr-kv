// Import fake-indexeddb polyfill first
import 'fake-indexeddb/auto';

// Import necessary tools for testing
import { useWebSocketImplementation } from 'nostr-tools/pool';
import { finalizeEvent, generateSecretKey, getPublicKey } from 'nostr-tools/pure';
import { matchFilters } from 'nostr-tools/filter';
import WebSocket from 'ws';
import { Server } from 'mock-socket';
import debug from 'debug';
import path from 'node:path'; // Import path for filename logic
import { fileURLToPath } from 'node:url'; // Import fileURLToPath for filename logic

// catch any uncaught errors or promise errors and print them
// Catch any uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

// Catch unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// Setup debug loggers
const logRelay = debug('nostr-kv:relay');
const logTest = debug('nostr-kv:test');

export class MockRelay {
  constructor(url) {
    this._serial = Math.floor(Math.random() * 10000);
    this.url = url || `wss://random.mock.relay/${this._serial}`;
    this.secretKeys = [generateSecretKey(), generateSecretKey(), generateSecretKey(), generateSecretKey()];
    this.preloadedEvents = this.secretKeys.map(sk =>
      finalizeEvent(
        {
          kind: 1,
          content: 'autogenerated by relay',
          created_at: Math.floor(Date.now() / 1000),
          tags: [['t', 'auto']],
        },
        sk,
      ),
    );

    logRelay(`Created relay at ${this.url}`);
    this._server = new Server(this.url);
    this._connections = new Map(); // Map connection to connection ID
    this._subscriptions = new Map(); // Map subscription ID to subscription details
    this._connectionCounter = 0;
    this._server.on('connection', (conn) => {
      const connId = ++this._connectionCounter;
      logRelay(`New connection #${connId} established`);
      this._connections.set(conn, connId);

      // Track subscriptions for this connection
      let connSubs = {};

      conn.on('message', (message) => {
        logRelay(`Connection #${connId} received message: ${message.slice(0, 100)}...`);
        const data = JSON.parse(message);

        switch (data[0]) {
          case 'REQ': {
            let subId = data[1];
            let filters = data.slice(2);
            logRelay(`Connection #${connId} created subscription ${subId} with filters: ${JSON.stringify(filters)}`);

            // Store subscription details
            connSubs[subId] = { conn, filters };
            this._subscriptions.set(`${connId}:${subId}`, { connId, subId, filters });

            // Log all active subscriptions
            logRelay(`Active subscriptions: ${Array.from(this._subscriptions.keys()).join(', ')}`);

            // Send preloaded events that match the filters
            let matchCount = 0;
            this.preloadedEvents.forEach(event => {
              if (matchFilters(filters, event)) {
                matchCount++;
                conn.send(JSON.stringify(['EVENT', subId, event]));
              }
            });
            logRelay(`Sent ${matchCount} preloaded events for subscription ${connId}:${subId}`);

            // Generate additional events based on filters
            filters.forEach((filter) => {
              const kinds = filter.kinds?.length ? filter.kinds : [1];

              kinds.forEach(kind => {
                this.secretKeys.forEach(sk => {
                  const event = finalizeEvent(
                    {
                      kind,
                      content: 'kind-aware autogenerated by relay',
                      created_at: Math.floor(Date.now() / 1000),
                      tags: [['t', 'auto']],
                    },
                    sk,
                  );

                  if (matchFilters([filter], event)) {
                    conn.send(JSON.stringify(['EVENT', subId, event]));
                  }
                });
              });
            });

            conn.send(JSON.stringify(['EOSE', subId]));
            logRelay(`Sent EOSE for subscription ${subId}`);
            break;
          }
          case 'CLOSE': {
            let subId = data[1];
            logRelay(`Connection #${connId} closing subscription ${subId}`);
            delete connSubs[subId];
            this._subscriptions.delete(`${connId}:${subId}`);
            break;
          }
          case 'EVENT': {
            let event = data[1];
            conn.send(JSON.stringify(['OK', event.id, true, '']));

            logRelay(`Connection #${connId} published event: kind=${event.kind} from pubkey=${event.pubkey.slice(0, 8)}`);
            logRelay(`Event content length: ${event.content.length} bytes`);
            logRelay(`Event tags: ${JSON.stringify(event.tags)}`);

            // Store the event for future subscribers
            this.preloadedEvents.push(event);

            // Broadcast to ALL subscriptions across ALL connections
            let broadcastCount = 0;

            // Log all subscriptions for debugging
            logRelay(`Broadcasting to ${this._subscriptions.size} subscriptions`);

            // Collect matching subscriptions for delayed broadcast
            const matchingSubscriptions = [];

            // Broadcast to all subscriptions
            for (const [subKey, sub] of this._subscriptions.entries()) {
              const { connId: targetConnId, subId, filters } = sub;

              logRelay(`Checking if event matches filters for subscription ${subKey}`);

              if (matchFilters(filters, event)) {
                const targetConn = Array.from(this._connections.entries())
                  .find(([_, id]) => id === targetConnId)?.[0];

                if (targetConn) {
                  logRelay(`Event matches subscription ${subKey}, will broadcast with delay`);
                  matchingSubscriptions.push({
                    conn: targetConn,
                    subId: subId,
                    event: event
                  });
                } else {
                  logRelay(`Connection #${targetConnId} not found for subscription ${subId}`);
                }
              } else {
                logRelay(`Event doesn't match filters for subscription ${subKey}`);
                logRelay(`Filters: ${JSON.stringify(filters)}`);
              }
            }

            // Broadcast with random delays to simulate network latency
            matchingSubscriptions.forEach(sub => {
              // Random delay between 50-300ms to simulate network latency
              const delay = 50 + Math.floor(Math.random() * 250);
              setTimeout(() => {
                logRelay(`Broadcasting event to subscription ${sub.subId} after ${delay}ms delay`);
                sub.conn.send(JSON.stringify(['EVENT', sub.subId, sub.event]));
                broadcastCount++;
              }, delay);
            });

            logRelay(`Event scheduled for broadcast to ${matchingSubscriptions.length} subscriptions with random delays`);
            break;
          }
        }
      });

      conn.on('close', () => {
        logRelay(`Connection #${connId} closed`);

        // Remove all subscriptions for this connection
        for (const [subKey, sub] of this._subscriptions.entries()) {
          if (sub.connId === connId) {
            logRelay(`Removing subscription ${subKey} due to connection close`);
            this._subscriptions.delete(subKey);
          }
        }

        this._connections.delete(conn);
      });
    });
  }

  get authors() {
    return this.secretKeys.map(getPublicKey);
  }

  get ids() {
    return this.preloadedEvents.map(evt => evt.id);
  }

  // Method to check if an event matches any subscription
  checkEventAgainstSubscriptions(event) {
    logRelay(`Checking event ${event.id.slice(0, 8)} against all subscriptions`);
    let matchCount = 0;

    for (const [subKey, sub] of this._subscriptions.entries()) {
      if (matchFilters(sub.filters, event)) {
        logRelay(`Event matches subscription ${subKey}`);
        matchCount++;
      }
    }

    logRelay(`Event matches ${matchCount} subscriptions`);
    return matchCount > 0;
  }

  // Debug method to print all active subscriptions
  printSubscriptions() {
    logRelay(`=== Active Subscriptions ===`);
    for (const [subKey, sub] of this._subscriptions.entries()) {
      logRelay(`Subscription ${subKey}:`);
      logRelay(`  Filters: ${JSON.stringify(sub.filters)}`);
    }
    logRelay(`=== End Subscriptions ===`);
  }
}

/**
 * Setup test environment with either mock or real relays
 * @returns {Object} Configuration for tests
 */
export function setupTestEnvironment() {
  // Determine if we should use real relays or mock relays
  const useRealRelays = process.env.RELAYS !== undefined;
  const realRelays = useRealRelays
    ? process.env.RELAYS.split(',').map(url => url.trim())
    : null;

  // Setup the appropriate WebSocket implementation
  if (useRealRelays) {
    useWebSocketImplementation(WebSocket);
    logTest(`Using real relays: ${realRelays.join(', ')}`);
  } else {
    useWebSocketImplementation(null);
    // For mock relays, we don't need to set a custom WebSocket implementation
    logTest('Using mock relays');
  }

  // Create mock relays if needed
  const mockRelays = !useRealRelays ? Array.from({ length: 3 }, () => new MockRelay()) : [];
  const relayURLs = useRealRelays ? realRelays : mockRelays.map(mr => mr.url);

  return {
    useRealRelays,
    mockRelays,
    relayURLs
  };
}

/**
 * Helper to log with timestamp
 */
export function log() {
  logTest.apply(null, Array.from(arguments));
}

/**
 * Logs the start of a test file.
 * @param {string} importMetaUrl - The import.meta.url of the calling test file.
 */
export function logTestStart(importMetaUrl) {
  const __filename = fileURLToPath(importMetaUrl);
  const currentFileName = path.basename(__filename);
  console.log(`\n--- Running test: ${currentFileName} ---`);
}
